diff --git a/tools/xenguest/Makefile b/tools/xenguest/Makefile
index daaa3ba..5c59e70 100644
--- a/tools/xenguest/Makefile
+++ b/tools/xenguest/Makefile
@@ -14,9 +14,9 @@ all: build
 .PHONY: build
 build: $(PROGRAMS)
 
-xenguest: xenguest.o xenguest_stubs.o
+xenguest: xenguest.o xenguest_stubs.o control.o xg_emu.o
 	$(CC) $(CFLAGS) -o $@ $(LDFLAGS) $^ \
-		$(LDLIBS_libxentoollog) $(LDLIBS_libxenctrl) $(LDLIBS_libxenguest) $(LDLIBS_libxenstore)
+		$(LDLIBS_libxentoollog) $(LDLIBS_libxenctrl) $(LDLIBS_libxenguest) $(LDLIBS_libxenstore) -ljson-c -pthread
 
 .PHONY: install
 install: build
diff --git a/tools/xenguest/control.c b/tools/xenguest/control.c
new file mode 100644
index 0000000..ce065cb
--- /dev/null
+++ b/tools/xenguest/control.c
@@ -0,0 +1,578 @@
+#include <stdio.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+  
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/time.h>
+#include <pthread.h>
+#include <time.h>
+#include <inttypes.h>
+#include <json/json.h>
+
+#include "control.h"
+
+
+#include <xenctrl.h>
+#include <xenguest.h>
+#include <xenstore.h>
+
+#include "xg_internal.h"
+
+
+#define UNIX_PATH_MAX 128
+
+#define ERR(...) {xg_err(__VA_ARGS__); }
+// #define INFO(...) {xg_info(__VA_ARGS__); }
+#define INFO(...)
+#define ERRN(str1) xg_err("%s: %s failed with err %s", __func__, str1, strerror(errno));
+
+EMP_COMMANDS(commands);
+
+#define max_clients 4
+static int client_socket[max_clients];
+static int chk[max_clients];
+
+static struct {
+   sem_t sem;
+   struct command_actions *actions;
+} runstate;
+
+int reply(struct demu_client cli, char* msg)
+{
+    int num = cli.num;
+    int remaining;
+    int r = 0;
+    INFO("relpying to (%d,%d): %s",num, cli.chk, msg);
+    if ( chk[num] != cli.chk) {
+        ERR("Waring: client (%d,%d) disconnected\n", num, cli.chk);
+        errno=EPIPE;
+        return -1;
+    }
+    remaining = strlen(msg);
+    while (remaining > 0) {
+       r = send(client_socket[num] , &msg[remaining-strlen(msg)] , remaining , MSG_NOSIGNAL );
+       if (r < 0)
+       {
+          ERR("write to client (%d,%d) failed with %s", num, cli.chk, strerror(errno));
+         return r;
+       }
+       remaining-=r;
+    }
+    return r;
+}
+
+int send_return(struct demu_client cli, char* ret)
+{
+   char msg[256];
+   sprintf(msg, "{ \"return\" : %s }\n", (ret)?ret:"{}");
+   return reply(cli, msg);
+}
+
+/*
+
+Example:
+
+{"timestamp": {"seconds": 1432121972, "microseconds": 744001},
+ "event": "MIGRATION", "data": {"status": "completed"}}
+
+*/
+
+const char evt_mig_hdr[]= "{ \"event\" : \"MIGRATION\", \"data\": {";
+const char evt_mig_cmp[]= "\"status\":\"completed\"";
+const char evt_mig_res[]= "\"result\":\"";
+const char evnt_mig_ftr[]= "}}\n";
+
+int send_event_migrate_completed_result(struct demu_client cli, char* result)
+{
+   char msg[128];
+   int r; 
+
+   INFO("Sending event");
+   r = snprintf(msg, sizeof(msg), "%s%s,\"result\":\"%s\"%s", 
+               evt_mig_hdr, evt_mig_cmp, result, evnt_mig_ftr);
+   if (r < 0 || r >= sizeof(msg)) {
+        ERR("failed to sent compleat with result");
+        return -1;
+   }
+   return reply(cli, msg);
+}
+
+
+int send_event_migrate_completed(struct demu_client cli)
+{
+   char msg[256];
+   INFO("Sending event");
+
+   snprintf(msg,sizeof(msg), "%s%s%s", evt_mig_hdr, evt_mig_cmp, evnt_mig_ftr);
+   return reply(cli, msg);
+}
+
+
+
+int send_event_migrate_progress(struct demu_client cli, int sent, int remaining, int iter)
+{
+   char msg[256];
+   char iters[60] = "";
+
+   if (iter>=0)
+     snprintf(iters, sizeof(iters), ",\"iteration\": %d", iter);
+
+   snprintf(msg, sizeof(msg), "%s\"sent\": %d,\"remaining\": %d%s%s",
+            evt_mig_hdr, sent, remaining, iters, evnt_mig_ftr);
+
+   return reply(cli, msg);
+}
+
+int send_event(struct demu_client cli, char* ret)
+{
+   char msg[256];
+   sprintf(msg, "{ \"event\" : %s }\n", (ret)?ret:"{}");
+   return reply(cli, msg);
+}
+
+int send_error(struct demu_client cli, char* ret)
+{
+   char msg[256];
+   snprintf(msg, sizeof(msg), "{ \"error\" : \"%s\" }\n", ret);
+   return reply(cli, msg);
+}
+
+
+void* run_thread(void *vargs) {
+   struct threadargs* args = (struct threadargs*) vargs;
+   int r;
+
+   args->func(args);
+
+   if (args->is_locked) {
+       r = sem_wait(args->sem);
+       if (r)
+          ERR("Failed to unlock due to %s", strerror(r))
+       else
+          args->is_locked = 0;
+   }
+   json_object_put(args->cmd_args);
+   free(args);
+   return NULL;
+}
+
+int emp_lock(struct threadargs *args)
+{
+   int r;
+   if (!args->is_locked){
+       r = sem_wait(args->sem);
+       if (r) {
+          ERR("Failed to lock due to %s", strerror(r));
+          return -1;
+       }
+       args->is_locked = 1;
+       return 0;
+   } else {
+       ERR("Error - locking locked lock");
+       return -1;
+   }
+}
+
+int emp_unlock(struct threadargs *args)
+{
+   int r;
+   if (args->is_locked){
+        r = sem_post(args->sem);
+       if (r) {
+          ERR("Failed to unlock due to %s", strerror(r));
+          return -1;
+       }
+       args->is_locked = 0;
+       return 0;
+   } else {
+       ERR("Error - unlocking unlocked lock");
+       return -1;
+   }
+}
+
+
+int control_lock() {
+
+    sem_wait(&runstate.sem);
+    return 0;
+}
+
+int control_unlock() {
+    sem_post(&runstate.sem);
+    return 0;
+}
+
+int run_in_thread(void (*func) (struct threadargs *), struct threadargs *args)
+{
+   struct threadargs *targs;
+   pthread_t thread;
+   int rc;
+
+   targs = malloc(sizeof(struct threadargs));
+   memcpy(targs, args, sizeof(*args));
+   targs->func = func;
+
+   rc = pthread_create(&thread, NULL, run_thread, targs);
+   if (rc == 0)
+       pthread_detach(thread);
+   else {
+      sem_post(targs->sem);
+      if (args->fd != -1)
+          close(args->fd);
+      send_error(args->cli, "thread fail");
+   }
+   return rc;
+}
+
+int json_get_command(json_object * jobj, const char **cmd, json_object **params)
+{
+ *params=NULL;
+ *cmd=NULL;
+
+ json_object_object_foreach(jobj, key, val) {
+
+ if ((strcmp(key, "execute") == 0) && (json_object_get_type(val) == json_type_string)) {
+      if (*cmd)
+          return -1;
+      else
+          *cmd = json_object_get_string(val);
+ } else if ((strcmp(key, "arguments") == 0) && (json_object_get_type(val) == json_type_object)) {
+      if (*params) {
+          return -1;
+      }
+      else {
+          *params= val;
+      }
+ } else
+     return -1;
+
+ }
+ if (*cmd == NULL)
+    return -1;
+
+ return 0;
+}
+
+int get_string(char *in_string, char **out_string, int *len) {
+   int i;
+   *out_string = in_string;
+   for (i = 0; in_string[i] > 0x20; i++);
+   *len = i;
+   return (i == 0);
+}
+
+
+static void process_message(struct demu_client cli, char* msg, int sent_fd)
+{
+   int rc=1;
+   int i;
+   int need_fd;
+   enum command_num cmd;
+   struct threadargs targs;
+   const char *cmd_str;
+   json_object *jobj;
+   json_object *params;
+
+   INFO("On (%d,%d) got message '%s'", cli.num, cli.chk,  msg);
+
+   jobj = json_tokener_parse(msg);
+
+   if (jobj==NULL) {
+       printf("Bad json!\n");
+       return;
+   }
+   if (json_get_command(jobj, &cmd_str, &params)) {
+       send_error(cli, "Invalid EMP");
+     return;
+   }
+
+   for (i=0; i < cmd_number; i++) {
+     rc = strcmp(cmd_str, commands[i].name);
+     if (rc <= 0)
+        break;
+   }
+   if (rc != 0 ) {
+      send_error(cli, "Invalid command.");
+      return;
+   }
+   need_fd = commands[i].fd;
+   cmd = commands[i].number;
+
+   targs.cli = cli;
+   targs.fd = sent_fd;
+   targs.sem = &runstate.sem;
+   targs.is_locked = 1;
+   targs.cmd_args = params;
+
+   for (i=0; i < cmd_number; i++) {
+       struct command_actions *action = &runstate.actions[i];
+
+       if (action->cmd == cmd) {
+
+           if (need_fd)
+           {
+              if (sent_fd == -1) {
+                 send_error(cli, "Expected FD");
+                 return;
+              }
+              /* pack fd */
+           } else {
+              if (sent_fd != -1) {
+                 close(sent_fd);
+                 send_error(cli, "Unexpected FD");
+                 return;
+              }
+           }
+           if (sem_wait(&runstate.sem))
+           {
+               send_error(cli, "internal error");
+               ERR("Semephore failed to lock with %s", strerror(errno));
+               return;
+           }
+
+           if (action->in_thread) {
+                 json_object_get(params);
+                 run_in_thread(action->func, &targs);
+           } else {
+                  action->func(&targs);
+                  emp_unlock(&targs);
+           }
+           return;
+       }
+   }
+   send_error(cli, "Not Implemented.");
+   json_object_put (jobj);
+
+}
+
+static int recv_fd(int socket, char *message_buffer, size_t count, int* sent_fd)
+{
+   struct msghdr socket_message;
+   struct iovec io_vector[1];
+   struct cmsghdr *control_message = NULL;
+   char ancillary_element_buffer[CMSG_SPACE(sizeof(int))];
+   int bytes;
+   *sent_fd = -1;
+
+   /* start clean */
+   memset(&socket_message, 0, sizeof(struct msghdr));
+   memset(ancillary_element_buffer, 0, CMSG_SPACE(sizeof(int)));
+
+   /* setup a place to fill in message contents */
+   io_vector[0].iov_base = message_buffer;
+   io_vector[0].iov_len = count;
+   socket_message.msg_iov = io_vector;
+   socket_message.msg_iovlen = 1;
+
+   /* provide space for the ancillary data */
+   socket_message.msg_control = ancillary_element_buffer;
+   socket_message.msg_controllen = CMSG_SPACE(sizeof(int));
+   bytes = recvmsg(socket, &socket_message, MSG_CMSG_CLOEXEC);
+   if (bytes <= 0) {
+      return bytes;
+   }
+
+   if((socket_message.msg_flags & MSG_CTRUNC) == MSG_CTRUNC)
+   {
+      /* we did not provide enough space for the ancillary element array */
+      errno=EMSGSIZE;
+      return -1;
+   }
+
+   /* iterate ancillary elements */
+   for(control_message = CMSG_FIRSTHDR(&socket_message);
+       control_message != NULL;
+       control_message = CMSG_NXTHDR(&socket_message, control_message))
+   {
+      if( (control_message->cmsg_level == SOL_SOCKET) &&
+          (control_message->cmsg_type == SCM_RIGHTS) )
+      {
+         *sent_fd = *((int *) CMSG_DATA(control_message));
+         return bytes;
+      }
+   }
+   return bytes;
+}
+
+
+/* start here */
+
+int control_sock_init(char* socket_name, struct control_sock_inf *inf, struct command_actions actions[])
+{
+   int i;
+   int opt = TRUE;
+   int r;
+
+   r = sem_init(&runstate.sem, 0, 1);
+
+   if (r) {
+        ERR("semaphore init failed - %s \n", strerror(r));
+        return -1;
+   }
+
+   runstate.actions = actions;
+   //initialise all client_socket[] to 0 so not checked
+   for (i = 0; i < max_clients; i++)
+   {
+       client_socket[i] = 0;
+       chk[i] = 0;
+   }
+
+   inf->master_socket = socket(PF_UNIX, SOCK_STREAM, 0);
+   if(inf->master_socket < 0)
+   {
+        ERRN("socket()");
+        return -1;
+   }
+
+   unlink(socket_name);
+
+   if( setsockopt(inf->master_socket, SOL_SOCKET, SO_REUSEADDR, (char *)&opt, sizeof(opt)) < 0 )
+   {
+        ERRN("setsockopt()");
+        return -1;
+   }
+
+   /* start with a clean address structure */
+   memset(&inf->address, 0, sizeof(struct sockaddr_un));
+
+   inf->address.sun_family = AF_UNIX;
+   snprintf(inf->address.sun_path, UNIX_PATH_MAX, "%s", socket_name);
+
+   if(bind(inf->master_socket,
+           (struct sockaddr *) &inf->address,
+           sizeof(struct sockaddr_un)) != 0)
+   {
+         ERR("bind() to %s failed with %s", socket_name, strerror(errno));
+         return -1;
+   }
+
+   //try to specify maximum of 3 pending connections for the master socket
+   if (listen(inf->master_socket, 3) < 0)
+   {
+        ERRN("listen()");
+        exit(EXIT_FAILURE);
+   }
+
+   inf->next_chk=1;
+   return 0;
+}
+
+int control_fdset(struct control_sock_inf *inf, fd_set *fds, int* num_clients)
+{
+    int max_fd;
+    int client;
+    int fd;
+    if (num_clients)
+       *num_clients = 0;
+    //add master socket to set
+    FD_SET(inf->master_socket, fds);
+    max_fd = inf->master_socket;
+
+
+    //add child sockets to set
+    for ( client = 0 ; client < max_clients ; client++)
+        {
+            //socket descriptor
+            fd = client_socket[client];
+
+            //if valid socket descriptor then add to read list
+            if(fd > 0) {
+                FD_SET( fd , fds);
+                if (num_clients)
+                    (*num_clients)++;
+            }
+            //highest file descriptor number, need it for the select function
+            if(fd > max_fd)
+                max_fd = fd;
+        }
+
+    return max_fd;
+
+}
+
+int control_fdread(struct control_sock_inf *inf, fd_set *fds, int activity)
+{
+    int  new_socket;
+    int i;
+    int addrlen = sizeof(inf->address);
+
+        if (FD_ISSET(inf->master_socket, fds)) 
+        {
+         //If something happened on the master socket , then its an incoming connection
+            int added = 0;
+            if ((new_socket = accept(inf->master_socket, (struct sockaddr *)&inf->address, (socklen_t*)&addrlen)) < 0)
+            {
+              ERRN("accept()");
+            } else {
+
+               //add new socket to array of sockets
+               for (i = 0; i < max_clients; i++) 
+               {
+                  //if position is empty
+                  if( client_socket[i] == 0 )
+                  {
+                    int nchk= inf->next_chk;
+                    client_socket[i] = new_socket;
+
+                    chk[i]= nchk++;
+                    inf->next_chk = (nchk) ? nchk : 1;
+                    ERR("Adding client on fd %d as (%d,%d)" , new_socket, i, chk[i]);
+                    added=1;
+                    break;
+                  }
+               }
+               if (!added) {
+                   ERR("WARNING: Failed to find slot for client on fd %d", new_socket);
+               }
+            }
+            activity--;
+        }
+
+        // Look for input from existing clients
+        for (i = 0; (activity >= 0) && (i < max_clients); i++) 
+        {
+            int fd = client_socket[i];
+
+            if (FD_ISSET( fd , fds)) 
+            {
+                int sent_fd = -1;
+                int valread;
+                char buffer[128];
+
+                valread = recv_fd(fd, buffer, 128, &sent_fd);
+
+                // If valread ==0, client disconnected
+                if (valread == 0)
+                {
+                    INFO("Host disconnected fd %d  (%d,%d)" , fd, i, chk[i]);
+
+                    //Close the socket and mark as 0 in list for reuse
+                    close( fd );
+                    client_socket[i] = 0;
+                    chk[i]=0;
+                }
+                else if (valread <0)
+                {
+                    ERR("Reading value on %d (%d,%d): %d failed with %s", fd,i, chk[i], valread, strerror(errno));
+                }
+                else
+                {
+                    //Prepare message, and send for processing.
+                    struct demu_client dc = { .num = i, .chk= chk[i] };
+                    buffer[valread] = '\0';
+                    process_message(dc, buffer, sent_fd);
+                }
+            activity--;
+            }
+        }
+    return activity;
+}
+
diff --git a/tools/xenguest/control.h b/tools/xenguest/control.h
new file mode 100644
index 0000000..76b4347
--- /dev/null
+++ b/tools/xenguest/control.h
@@ -0,0 +1,76 @@
+#include <semaphore.h>
+#include <sys/un.h>
+#include "emp.h"
+#include <json/json.h>
+struct demu_client {
+  int num;
+  int chk;
+};
+/*
+enum command_num {
+    cmd_migrate_abort,
+    cmd_migrate_init,
+    cmd_migrate_live,
+    cmd_migrate_pause,
+    cmd_migrate_paused,
+    cmd_migrate_progress,
+    cmd_quit,
+    cmd_number
+};
+#define EMP_COMMANDS(_cmd_name)                     \
+struct command_names _cmd_name[] = {                \
+    {"migrate_abort",0, cmd_migrate_abort},         \
+    {"migrate_init",1, cmd_migrate_init},           \
+    {"migrate_live",0, cmd_migrate_live},           \
+    {"migrate_pause",0, cmd_migrate_pause},         \
+    {"migrate_paused",0, cmd_migrate_paused},       \
+    {"migrate_progress",0, cmd_migrate_progress},   \
+    {"quit", 0, cmd_quit}                           \
+}
+*/
+
+
+struct args_list {
+    struct args_list* next;
+    char *key;
+    char *value;
+};
+
+
+struct threadargs {
+    struct demu_client cli;
+    int fd;
+    json_object *cmd_args;
+    sem_t *sem;
+    int is_locked;
+    void (*func)(struct threadargs *);
+};
+
+struct command_actions {
+   enum command_num cmd;
+   void (*func)(struct threadargs *);
+   int in_thread;
+};
+
+
+struct control_sock_inf {
+
+   int master_socket;
+   struct sockaddr_un address;
+   int next_chk;
+};
+
+
+int control_sock_init(char *name, struct control_sock_inf *inf, struct command_actions actions[]);
+int control_fdset(struct control_sock_inf *inf, fd_set *fds, int* num_clients);
+int control_fdread(struct control_sock_inf *inf, fd_set *fds, int activity);
+int control_lock(void);
+int control_unlock(void);
+
+int send_event_migrate_completed(struct demu_client cli);
+int send_event_migrate_completed_result(struct demu_client cli, char* result);
+int send_event_migrate_progress(struct demu_client cli, int sent, int remaining, int iter);
+int send_return(struct demu_client cli, char* ret);
+int send_error(struct demu_client cli, char* ret);
+int emp_lock(struct threadargs *args);
+int emp_unlock(struct threadargs *args);
diff --git a/tools/xenguest/emp.h b/tools/xenguest/emp.h
new file mode 100644
index 0000000..dd46d68
--- /dev/null
+++ b/tools/xenguest/emp.h
@@ -0,0 +1,36 @@
+enum command_num {
+    cmd_track_dirty,
+    cmd_migrate_abort,
+    cmd_migrate_init,
+    cmd_migrate_live,
+    cmd_migrate_pause,
+    cmd_migrate_paused,
+    cmd_migrate_progress,
+    cmd_migrate_nonlive,
+    cmd_restore,
+    cmd_quit,
+    cmd_set_args,
+    cmd_number
+};
+
+struct command_names {
+   char *name;
+   char fd;
+   enum command_num number;
+};
+
+#define EMP_COMMANDS(_cmd_name)                     \
+struct command_names _cmd_name[] = {                \
+    {"migrate_abort",0, cmd_migrate_abort},         \
+    {"migrate_init",1, cmd_migrate_init},           \
+    {"migrate_live",0, cmd_migrate_live},           \
+    {"migrate_nonlive",0, cmd_migrate_nonlive},     \
+    {"migrate_pause",0, cmd_migrate_pause},         \
+    {"migrate_paused",0, cmd_migrate_paused},       \
+    {"migrate_progress",0, cmd_migrate_progress},   \
+    {"quit", 0, cmd_quit},                          \
+    {"restore", 0, cmd_restore},                    \
+    {"set_args", 0, cmd_set_args},                  \
+    {"track_dirty", 0, cmd_track_dirty}             \
+}
+
diff --git a/tools/xenguest/xenguest.c b/tools/xenguest/xenguest.c
index 8998dd1..2c631b7 100644
--- a/tools/xenguest/xenguest.c
+++ b/tools/xenguest/xenguest.c
@@ -89,6 +89,7 @@ static const char *xg_mode_names[] = {
     [XG_MODE_LINUX_BUILD] = "linux_build",
     [XG_MODE_HVM_BUILD] = "hvm_build",
     [XG_MODE_TEST] = "test",
+    [XG_MODE_LISTEN] = "listen"
 };
 
 xc_interface *xch = NULL;
@@ -169,11 +170,15 @@ static void progressfn(struct xentoollog_logger *logger,
 {
     static struct timeval lasttime = { 0 };
     struct timeval curtime;
+    uint64_t time_delta;
 
     gettimeofday(&curtime, NULL);
+    time_delta = tv_delta_us(&curtime, &lasttime);
+ 
+    send_emu_progress(done, total);
 
-    if ( (done == 0) || (done == total) ||
-         (tv_delta_us(&curtime, &lasttime) > (5UL * 1000 * 1000)) )
+    if ( (( done == 0 || done == total ) && (time_delta > 1UL * 500 * 1000 ))
+         || (time_delta > 5UL * 1000 * 1000) )
     {
         if ( done == 0 && total == 0 )
             xg_info("progress: %s\n", doing_what);
@@ -586,6 +591,9 @@ int main(int argc, char * const argv[])
         case XG_MODE_HVM_SAVE:
             suffix = "-save";
             break;
+        case XG_MODE_LISTEN:
+            suffix = "-emp";
+            break;
 
         case XG_MODE_RESTORE:
         case XG_MODE_HVM_RESTORE:
@@ -672,6 +680,9 @@ int main(int argc, char * const argv[])
     case XG_MODE_TEST:
         do_test();
         break;
+    case XG_MODE_LISTEN:
+        emp_do_listen();
+        break;
     }
 
     free(xs_domain_path);
diff --git a/tools/xenguest/xenguest_stubs.c b/tools/xenguest/xenguest_stubs.c
index 4ba6384..d8a2792 100644
--- a/tools/xenguest/xenguest_stubs.c
+++ b/tools/xenguest/xenguest_stubs.c
@@ -1,4 +1,4 @@
-/*
+ /*
  * Copyright (C) 2006-2009 Citrix Systems Inc.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -1090,6 +1090,29 @@ void migration_safety_checks(void)
 
 #define GENERATION_ID_ADDRESS "hvmloader/generation-id-address"
 
+int emu_stub_xc_domain_save(int fd, void* data,
+                        int flags, int hvm)
+{
+    int r;
+    struct save_callbacks callbacks =
+        {
+            .suspend = emu_suspend_callback,
+            .switch_qemu_logdirty = switch_qemu_logdirty,
+            .data = data,
+            .precopy_policy = xenguest_precopy_policy,
+        };
+
+    migration_safety_checks();
+
+    r = xc_domain_save(xch, fd, domid,
+                       flags, &callbacks, hvm, 0, -1);
+    if (r)
+        failwith_oss_xc("xc_domain_save");
+
+    return 0;
+}
+
+
 int stub_xc_domain_save(int fd, int max_iters, int max_factors,
                         int flags, int hvm)
 {
diff --git a/tools/xenguest/xg_emu.c b/tools/xenguest/xg_emu.c
new file mode 100644
index 0000000..c4de820
--- /dev/null
+++ b/tools/xenguest/xg_emu.c
@@ -0,0 +1,418 @@
+#include <xenctrl.h>
+#include <xenguest.h>
+#include <xenstore.h>
+#include <libgen.h>
+#include <sys/stat.h>
+#include <semaphore.h>
+#include <time.h>
+#include "xg_internal.h"
+#include "control.h"
+
+
+static sem_t sem_stopped;
+static int live_stage = XGS_POLICY_CONTINUE_PRECOPY;
+static int hvm_mode = true;
+
+struct demu_client progress_cli = { .num = -1 };
+static int last_iter = 0;
+static uint64_t last_sent = 0;
+static int stream_fd = -1;
+
+
+static int arg_store_port = -1;
+static int arg_console_port = -1;
+
+static int xg_flags = 0;
+
+
+#define COMMAND_TIMOUT (60*2)
+
+int str_lookup(const char* table[], char cmp[]) {
+    int i;
+    for (i=0; table[i]; i++) {
+        if (strcmp(table[i], cmp)==0)
+           return i;
+    }
+    return -1;
+}
+
+/* Called for mid-iteration progress update */
+void send_emu_progress(unsigned long done, unsigned long total) {
+
+    struct timeval curtime;
+    static struct timeval lastprog = { 0 };
+
+    gettimeofday(&curtime, NULL);
+
+    if (progress_cli.num >= 0) {
+
+        if ( done == 0 || done == total ) {
+            lastprog = curtime;
+        } else if (tv_delta_us(&curtime, &lastprog) > 1UL * 500 * 1000){
+             /* Don't send dirty_conut, is out of date */
+              send_event_migrate_progress(progress_cli,  last_sent + done, -1 , last_iter);
+              lastprog = curtime;
+        }
+    }
+}
+
+
+
+static void do_cmd_progress(struct threadargs *args)
+{
+    progress_cli = args->cli;
+    xg_info("setting progress_cli to %d", progress_cli.num);
+    send_return(args->cli, NULL);
+}
+
+static int running=1;
+
+static void do_cmd_quit(struct threadargs *args)
+{
+   send_return(args->cli, NULL);
+   running = 0;
+}
+
+static void abort_all(void)
+{
+   live_stage = XGS_POLICY_ABORT;
+   /* post to sem, incase we are waiting */
+   sem_post(&sem_stopped);
+}
+
+static void do_abort(struct threadargs *args)  {
+   xg_err("Recived abort command!");
+   abort_all();
+   send_return(args->cli, NULL);
+}
+
+
+static void do_ignore(struct threadargs *args)  {
+   send_return(args->cli, NULL);
+}
+
+#if 0
+static void not_supported(struct threadargs *args)  {
+   xg_err("Not supported");
+   send_error(args->cli, "Not supported");
+}
+#endif
+
+static void do_migrate_init(struct threadargs *args)
+{
+
+   stream_fd = args->fd;
+   send_return(args->cli, NULL);
+   sem_init(&sem_stopped,0,0);
+//    sem_init(&sem_done,0,0);
+}
+
+int emu_suspend_callback(void *data)
+{
+   int r;
+   xg_info("waiting for suspend");
+   r=sem_wait(&sem_stopped);
+   if (live_stage == XGS_POLICY_ABORT) {
+       xg_info("Ignoring libxc suspend reqest do to abort");
+       return 0;
+   }
+
+   xg_info("suspend was recived");
+   return 1;
+}
+
+/* Monitor process */
+int xenguest_precopy_policy(
+    struct precopy_stats stats, void *user)
+{
+    int stop_decision = live_stage;
+    int r = 0;
+
+    if (stats.dirty_count >= 0) {
+        struct demu_client *cli = (struct demu_client *)user;
+        last_sent = stats.total_written;
+        last_iter = stats.iteration;
+
+        xg_info("Checking live policy.  %ld / %d for %d", stats.dirty_count, stats.total_written ,stats.iteration);
+        r = send_event_migrate_progress(*cli, stats.total_written, stats.dirty_count, stats.iteration);
+    }
+
+    if (stop_decision)
+         xg_info("passing down stop message");
+    else if (stats.dirty_count == 0) {
+         xg_info("No dirty pages, finishing migration");
+         stop_decision = XGS_POLICY_STOP_AND_COPY;
+    }
+
+   return stop_decision;
+}
+
+
+
+static void do_migrate_live(struct threadargs *args)
+{
+   xg_flags |= XCFLAGS_LIVE;
+   emp_unlock(args);
+
+   send_return(args->cli, NULL);
+
+   emu_stub_xc_domain_save(stream_fd, (void*) &args->cli, xg_flags, hvm_mode);
+   xg_info(" Finished, send compleate");
+   if (progress_cli.num >= 0)
+       send_event_migrate_completed(progress_cli);
+   else
+       xg_info("No cli watching");
+
+}
+
+static void do_migrate_nonlive(struct threadargs *args)
+{
+   xg_flags &= ~XCFLAGS_LIVE;
+   emp_unlock(args);
+
+   send_return(args->cli, NULL);
+
+   emu_stub_xc_domain_save(stream_fd, (void*) &args->cli, xg_flags, hvm_mode);
+   xg_info(" Finished, send compleate");
+   send_event_migrate_completed(args->cli);
+
+   if (progress_cli.num >= 0)
+       send_event_migrate_completed(progress_cli);
+   else
+       xg_info("No cli watching");
+
+}
+
+
+
+static void do_migrate_paused(struct threadargs *args)
+{
+   xg_info("Recived paused message");
+   send_return(args->cli, NULL);
+   sem_post(&sem_stopped);
+}
+
+static void do_migrate_pause(struct threadargs *args)
+{
+   xg_info("Recived pause message");
+   send_return(args->cli, NULL);
+   live_stage=XGS_POLICY_STOP_AND_COPY;
+}
+
+static void do_cmd_restore(struct threadargs *args) 
+{
+    unsigned long store_mfn = 0, console_mfn = 0;
+    char buf[64];
+
+    if (domid == -1 || stream_fd == -1
+        || arg_store_port == -1 || arg_console_port == -1) {
+        xg_err("xenguest: missing command line options\n");
+        send_error(args->cli, "Missing options");
+        return;
+    }
+    emp_unlock(args);
+
+    send_return(args->cli, NULL);
+
+    stub_xc_domain_restore(stream_fd, arg_store_port, arg_console_port, hvm_mode,
+                           &store_mfn, &console_mfn);
+
+    xg_info("Restore compleat, send result");
+    snprintf(buf, sizeof(buf) ,"%lu %lu", store_mfn, console_mfn );
+
+    if (progress_cli.num >= 0)
+       send_event_migrate_completed_result(progress_cli,buf);
+    if (progress_cli.num != args->cli.num)
+       send_event_migrate_completed_result(args->cli , buf);
+   xg_info("All done");
+}
+
+
+enum arg_keys {
+     unknown    = -1,
+     store_port = 0,
+     console_port,
+     mode_pv
+};
+
+const char* setable_args[] = {"store_port", "console_port","pv", NULL};
+
+void do_cmd_set_args(struct threadargs *args)
+{
+   json_object *jobj = args->cmd_args;
+   enum arg_keys key;
+   char* str_end;
+   const char* val;
+   int bad = 0;
+
+   if (jobj==NULL) {
+      xg_err("set_args called without any args");
+      send_error(args->cli, "No Args");
+      return;
+   }
+
+
+   json_object_object_foreach(jobj, s_key, jval) {
+
+      if (json_object_get_type(jval) != json_type_string) {
+          xg_err("expecting only string argemunts.  (%s)", s_key);
+          bad = 1;
+          continue;
+      }
+      val = json_object_get_string(jval);
+
+       key = str_lookup(setable_args, s_key);
+       switch (key) {
+       case store_port:
+            arg_store_port = strtol(val, &str_end, 10);
+            if (*str_end != '\0') {
+                 arg_store_port =-1;
+                 xg_err("Bad arge %s = %s", s_key, val);
+                 bad = 1;
+            }
+            xg_info("store port = %d", arg_store_port);
+       break;
+       case console_port:
+
+            arg_console_port = strtol(val, &str_end, 10);
+            if (*str_end != '\0') {
+                 arg_console_port =-1;
+                 xg_err("Bad arge %s = %s", s_key, val);
+                 bad = 1;
+            }
+            xg_info("console port = %d", arg_console_port);
+       break;
+       case mode_pv:
+            hvm_mode = false;
+       break;
+       default:
+           xg_err("Unknown arg: %s", s_key);
+       }
+   }
+   if (bad) {
+      send_error(args->cli, "Bad Args");
+   } else {
+      send_return(args->cli, NULL);
+   }
+}
+
+
+
+struct command_actions actions[] = {
+    {cmd_track_dirty,      &do_ignore, 0 },
+    {cmd_migrate_abort,    &do_abort, 0 },
+    {cmd_migrate_init,     &do_migrate_init, 0 },
+    {cmd_migrate_live,     &do_migrate_live, 1 },
+    {cmd_migrate_pause,    &do_migrate_pause, 0 },
+    {cmd_migrate_paused,   &do_migrate_paused, 0 },
+    {cmd_migrate_progress, &do_cmd_progress,  0 },
+    {cmd_migrate_nonlive,  &do_migrate_nonlive, 1},
+    {cmd_restore,          &do_cmd_restore, 1 },
+    {cmd_set_args,         &do_cmd_set_args, 0},
+    {cmd_quit,             &do_cmd_quit,      0 }
+};
+
+
+void emp_do_listen(void)
+{
+/*
+"migrate_init"-> stash.
+"Migrte_live" -> do_migrate
+"migrate_pause" -> maby stop living, and wait.
+"migrate_paused" -> stop and copy migrate. (stop waiting)
+"migate_progress" -> set bool, tranmit progess
+*/
+#define CONTROL_PATH "/var/xen/%s/%d/control"
+
+struct control_sock_inf cs_inf;
+   int rc;
+   char* fname;
+   char* path;
+   int r;
+   time_t act_time;
+
+   r = mkdir("/var/xen/xenguest", S_IRWXU | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
+
+   if (r!=0 && errno != EEXIST) {
+      xg_err("Couldn't create directory, %d", errno);
+      return;
+   }
+
+   r = asprintf(&fname, CONTROL_PATH, "xenguest", domid);
+
+   if (r<0) {
+        xg_err("no memory (fname)");
+        return;
+   }
+   path = strdup(fname);
+
+   if (path==NULL) {
+       xg_err("no memory (path)");
+       free(fname);
+       return;
+   }
+
+   r = mkdir(dirname(path), S_IRWXU | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
+   free(path);
+
+   if ((r!=0 && errno!= EEXIST)){
+        xg_err("could not make directory, %d", errno);
+        free(fname);
+        return;
+   }
+
+   r = control_sock_init(fname, &cs_inf, actions);
+   free(fname);
+
+   if (r) {
+       xg_err("control socket failed");
+       return;
+   }
+
+   act_time = time(0);
+
+   printf("Ready\n");
+
+   for (;running;) {
+        fd_set          rfds;
+        fd_set          wfds;
+        fd_set          xfds;
+        int             nfds;
+        int             num_clients;
+        struct timeval  tv;
+
+        FD_ZERO(&rfds);
+        FD_ZERO(&wfds);
+        FD_ZERO(&xfds);
+        tv.tv_sec = 30;
+        tv.tv_usec = 0;
+
+        nfds = control_fdset(&cs_inf, &rfds, &num_clients);
+        nfds++;
+        rc = select(nfds, &rfds, &wfds, &xfds, &tv);
+
+        if (rc == 0 && num_clients == 0) {
+           int timediff = time(0) - act_time;
+           if (timediff > COMMAND_TIMOUT) {
+               xg_err("Control timeout");
+               abort_all();
+               break;
+           }
+        }
+        else
+           act_time = time(0);
+
+        if (rc < 0 && errno != EINTR)
+            break;
+
+        if ( rc > 0)
+               rc = control_fdread(&cs_inf, &rfds, rc);
+
+    }
+    /* wait for any threads to finish */
+    control_lock();
+    control_unlock();
+
+}
+
+
diff --git a/tools/xenguest/xg_internal.h b/tools/xenguest/xg_internal.h
index c2cb248..d236a7a 100644
--- a/tools/xenguest/xg_internal.h
+++ b/tools/xenguest/xg_internal.h
@@ -15,6 +15,7 @@ enum xenguest_mode {
     XG_MODE_LINUX_BUILD,
     XG_MODE_HVM_BUILD,
     XG_MODE_TEST,
+    XG_MODE_LISTEN,
     XG_MODE__END__,
 };
 
@@ -28,6 +29,7 @@ extern xs_handle *xsh;
 extern int domid;
 extern bool force;
 
+
 /* Read and write /local/domain/$domid/ relative paths. */
 char *xenstore_getsv(const char *fmt, va_list ap);
 char *xenstore_gets(const char *fmt, ...)  __printf(1, 2);
@@ -45,8 +47,13 @@ int stub_xc_linux_build(int c_mem_max_mib, int mem_start_mib,
 int stub_xc_hvm_build(int mem_max_mib, int mem_start_mib, const char *image_name,
                       int store_evtchn, int store_domid, int console_evtchn,
                       int console_domid, unsigned long *store_mfn, unsigned long *console_mfn);
-int stub_xc_domain_save(int fd, int max_iters, int max_factors,
+
+int stub_xc_domain_save(int fd, int max_iters, int max_factors, int flags, int hvm);
+
+int emu_stub_xc_domain_save(int fd, void* data,
                         int flags, int hvm);
+
+
 int stub_xc_domain_restore(int fd, int store_evtchn, int console_evtchn,
                            int hvm,
                            unsigned long *store_mfn, unsigned long *console_mfn);
@@ -54,6 +61,9 @@ int stub_xc_domain_resume_slow(void);
 
 int suspend_callback(void *data);
 
+int emu_suspend_callback(void *data);
+
+
 void setup_legacy_conversion(int opt_fd, enum xenguest_mode mode);
 void cleanup_legacy_conversion(void);
 
@@ -68,6 +78,10 @@ static inline uint64_t tv_delta_us(const struct timeval *new,
             (new->tv_usec - old->tv_usec));
 }
 
+int xenguest_precopy_policy(struct precopy_stats stats, void *user);
+void emp_do_listen(void);
+void send_emu_progress(unsigned long done, unsigned long total);
+
 #endif
 
 /*
