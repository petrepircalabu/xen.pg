From ba22f1f4732acb4d5aebd779122e91753a0e374d Mon Sep 17 00:00:00 2001
From: Ross Lagerwall <ross.lagerwall@citrix.com>
Date: Tue, 15 Mar 2016 12:19:13 +0100
Subject: [PATCH] vmx: restore debug registers when injecting #DB traps

Commit a929bee0e652 ("x86/vmx: Fix injection of #DB traps following
XSA-156") prevents an infinite loop in certain #DB traps. However, it
changed the behavior to not call hvm_hw_inject_trap() for #DB and #AC
traps which which means that the debug registers are not restored
correctly and nullified commit b56ae5b48c38 ("VMX: fix/adjust trap
injection").

To fix this, restore the original code path through hvm_inject_trap(),
but ensure that the struct hvm_trap is populated with all the required
data.

Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
Reviewed-by: Jan Beulich <jbeulich@suse.com>
Acked-by: Kevin Tian <kevin.tian@intel.com>
diff --git a/xen/arch/x86/hvm/vmx/vmx.c b/xen/arch/x86/hvm/vmx/vmx.c
index 13d7809..7b3b064 100644
--- a/xen/arch/x86/hvm/vmx/vmx.c
+++ b/xen/arch/x86/hvm/vmx/vmx.c
@@ -2810,24 +2810,31 @@ static int vmx_handle_eoi_write(void)
  * It is the callers responsibility to ensure that this function is only used
  * in the context of an appropriate vmexit.
  */
-static void vmx_propagate_intr(void)
+static void vmx_propagate_intr(unsigned long intr)
 {
-    unsigned long intr, tmp;
-
-    __vmread(VM_EXIT_INTR_INFO, &intr);
-
-    ASSERT(intr & INTR_INFO_VALID_MASK);
-
-    __vmwrite(VM_ENTRY_INTR_INFO, intr);
+    struct hvm_trap trap = {
+        .vector = MASK_EXTR(intr, INTR_INFO_VECTOR_MASK),
+        .type = MASK_EXTR(intr, INTR_INFO_INTR_TYPE_MASK),
+    };
+    unsigned long tmp;
 
     if ( intr & INTR_INFO_DELIVER_CODE_MASK )
     {
         __vmread(VM_EXIT_INTR_ERROR_CODE, &tmp);
-        __vmwrite(VM_ENTRY_EXCEPTION_ERROR_CODE, tmp);
+        trap.error_code = tmp;
     }
+    else
+        trap.error_code = HVM_DELIVER_NO_ERROR_CODE;
+
+    if ( trap.type >= X86_EVENTTYPE_SW_INTERRUPT )
+    {
+        __vmread(VM_EXIT_INSTRUCTION_LEN, &tmp);
+        trap.insn_len = tmp;
+    }
+    else
+        trap.insn_len = 0;
 
-    __vmread(VM_EXIT_INSTRUCTION_LEN, &tmp);
-    __vmwrite(VM_ENTRY_INSTRUCTION_LEN, tmp);
+    hvm_inject_trap(&trap);
 }
 
 static void vmx_idtv_reinject(unsigned long idtv_info)
@@ -3078,7 +3085,7 @@ void vmx_vmexit_handler(struct cpu_user_regs *regs)
             HVMTRACE_1D(TRAP_DEBUG, exit_qualification);
             write_debugreg(6, exit_qualification | DR_STATUS_RESERVED_ONE);
             if ( !v->domain->debugger_attached )
-                vmx_propagate_intr();
+                vmx_propagate_intr(intr_info);
             else
                 domain_pause_for_debugger();
             break;
@@ -3147,7 +3154,7 @@ void vmx_vmexit_handler(struct cpu_user_regs *regs)
             break;
         case TRAP_alignment_check:
             HVMTRACE_1D(TRAP, vector);
-            vmx_propagate_intr();
+            vmx_propagate_intr(intr_info);
             break;
         case TRAP_nmi:
             if ( MASK_EXTR(intr_info, INTR_INFO_INTR_TYPE_MASK) !=
