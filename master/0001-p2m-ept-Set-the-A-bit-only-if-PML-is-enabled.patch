From 18a54c9b967dc41f7eb60d3d1bf83ffe94e67087 Mon Sep 17 00:00:00 2001
From: Ross Lagerwall <ross.lagerwall@citrix.com>
Date: Wed, 16 Sep 2015 09:33:12 +0100
Subject: [PATCH] p2m/ept: Set the A bit only if PML is enabled

Since commit 191b3f3344ee ("p2m/ept: enable PML in p2m-ept for
log-dirty"), the A and D bits of EPT paging entries are set
unconditionally, regardless of whether PML is enabled or not. This
causes a regression in Xen 4.6 on some processors due to Intel Errata
AVR41 -- HVM guests get severe memory corruption when the A bit is
set. The errata affects the Atom C2000 family (Avaton).

Instead, only set the bits if PML is enabled.
---
 xen/arch/x86/mm/p2m-ept.c | 38 ++++++++++++++++++++++++++------------
 1 file changed, 26 insertions(+), 12 deletions(-)

diff --git a/xen/arch/x86/mm/p2m-ept.c b/xen/arch/x86/mm/p2m-ept.c
index 2f3df91..4bea818 100644
--- a/xen/arch/x86/mm/p2m-ept.c
+++ b/xen/arch/x86/mm/p2m-ept.c
@@ -130,14 +130,18 @@ static void ept_p2m_type_to_flags(struct p2m_domain *p2m, ept_entry_t *entry,
             break;
         case p2m_ram_rw:
             entry->r = entry->w = entry->x = 1;
-            entry->a = entry->d = 1;
+            if ( vmx_domain_pml_enabled(p2m->domain) )
+                    entry->a = entry->d = 1;
             break;
         case p2m_mmio_direct:
             entry->r = entry->x = 1;
             entry->w = !rangeset_contains_singleton(mmio_ro_ranges,
                                                     entry->mfn);
-            entry->a = 1;
-            entry->d = entry->w;
+            if ( vmx_domain_pml_enabled(p2m->domain) )
+            {
+                entry->a = 1;
+                entry->d = entry->w;
+            }
             break;
         case p2m_ram_logdirty:
             entry->r = entry->x = 1;
@@ -152,29 +156,38 @@ static void ept_p2m_type_to_flags(struct p2m_domain *p2m, ept_entry_t *entry,
                 entry->w = 1;
             else
                 entry->w = 0;
-            entry->a = 1;
-            /* For both PML or non-PML cases we clear D bit anyway */
-            entry->d = 0;
+            if ( vmx_domain_pml_enabled(p2m->domain) )
+            {
+                entry->a = 1;
+                entry->d = 0;
+            }
             break;
         case p2m_ram_ro:
         case p2m_ram_shared:
             entry->r = entry->x = 1;
             entry->w = 0;
-            entry->a = 1;
-            entry->d = 0;
+            if ( vmx_domain_pml_enabled(p2m->domain) )
+            {
+                entry->a = 1;
+                entry->d = 0;
+            }
             break;
         case p2m_grant_map_rw:
         case p2m_map_foreign:
             entry->r = entry->w = 1;
             entry->x = 0;
-            entry->a = entry->d = 1;
+            if ( vmx_domain_pml_enabled(p2m->domain) )
+                entry->a = entry->d = 1;
             break;
         case p2m_grant_map_ro:
         case p2m_mmio_write_dm:
             entry->r = 1;
             entry->w = entry->x = 0;
-            entry->a = 1;
-            entry->d = 0;
+            if ( vmx_domain_pml_enabled(p2m->domain) )
+            {
+                entry->a = 1;
+                entry->d = 0;
+            }
             break;
     }
 
@@ -233,7 +246,8 @@ static int ept_set_middle_entry(struct p2m_domain *p2m, ept_entry_t *ept_entry)
 
     ept_entry->r = ept_entry->w = ept_entry->x = 1;
     /* Manually set A bit to avoid overhead of MMU having to write it later. */
-    ept_entry->a = 1;
+    if ( vmx_domain_pml_enabled(p2m->domain) )
+        ept_entry->a = 1;
 
     ept_entry->suppress_ve = 1;
 
-- 
2.1.0

