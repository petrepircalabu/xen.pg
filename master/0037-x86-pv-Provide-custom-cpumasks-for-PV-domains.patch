From f83654ce196ea4c992dae91272549786d58f2801 Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Thu, 26 Nov 2015 18:56:43 +0000
Subject: [PATCH 37/39] x86/pv: Provide custom cpumasks for PV domains

And use them in preference to cpumask_defaults on context switch.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
diff --git a/xen/arch/x86/cpu/amd.c b/xen/arch/x86/cpu/amd.c
index cc1344a..a925614 100644
--- a/xen/arch/x86/cpu/amd.c
+++ b/xen/arch/x86/cpu/amd.c
@@ -203,7 +203,9 @@ static void __init noinline probe_masking_msrs(void)
 void amd_ctxt_switch_levelling(const struct domain *nextd)
 {
 	struct cpumasks *these_masks = &this_cpu(cpumasks);
-	const struct cpumasks *masks = &cpumask_defaults;
+	const struct cpumasks *masks =
+            (nextd && is_pv_domain(nextd) && nextd->arch.pv_domain.masks)
+            ? nextd->arch.pv_domain.masks : &cpumask_defaults;
 
 #define LAZY(cap, msr, field)						\
 	({								\
diff --git a/xen/arch/x86/cpu/intel.c b/xen/arch/x86/cpu/intel.c
index 87c66d2..5d2ce3f 100644
--- a/xen/arch/x86/cpu/intel.c
+++ b/xen/arch/x86/cpu/intel.c
@@ -143,7 +143,7 @@ static void __init probe_masking_msrs(void)
 void intel_ctxt_switch_levelling(const struct domain *nextd)
 {
 	struct cpumasks *these_masks = &this_cpu(cpumasks);
-	const struct cpumasks *masks = &cpumask_defaults;
+	const struct cpumasks *masks;
 
 	if (cpu_has_cpuid_faulting) {
 		set_cpuid_faulting(nextd && is_pv_domain(nextd) &&
@@ -152,6 +152,9 @@ void intel_ctxt_switch_levelling(const struct domain *nextd)
 		return;
 	}
 
+	masks = (nextd && is_pv_domain(nextd) && nextd->arch.pv_domain.masks)
+		? nextd->arch.pv_domain.masks : &cpumask_defaults;
+
 #define LAZY(msr, field)						\
 	({								\
 		if ( msr && (these_masks->field != masks->field) )	\
diff --git a/xen/arch/x86/domain.c b/xen/arch/x86/domain.c
index e7897ab..51fd2ec 100644
--- a/xen/arch/x86/domain.c
+++ b/xen/arch/x86/domain.c
@@ -575,6 +575,12 @@ int arch_domain_create(struct domain *d, unsigned int domcr_flags,
             goto fail;
         clear_page(d->arch.pv_domain.gdt_ldt_l1tab);
 
+        d->arch.pv_domain.masks = xmalloc(struct cpumasks);
+        if ( !d->arch.pv_domain.masks )
+            goto fail;
+        memcpy(d->arch.pv_domain.masks, &cpumask_defaults,
+               sizeof(*d->arch.pv_domain.masks));
+
         rc = create_perdomain_mapping(d, GDT_LDT_VIRT_START,
                                       GDT_LDT_MBYTES << (20 - PAGE_SHIFT),
                                       NULL, NULL);
@@ -684,7 +690,10 @@ void arch_domain_destroy(struct domain *d)
 
     free_perdomain_mappings(d);
     if ( is_pv_domain(d) )
+    {
         free_xenheap_page(d->arch.pv_domain.gdt_ldt_l1tab);
+        xfree(d->arch.pv_domain.masks);
+    }
 
     free_xenheap_page(d->shared_info);
     cleanup_domain_irq_mapping(d);
diff --git a/xen/include/asm-x86/domain.h b/xen/include/asm-x86/domain.h
index d49b028..a051193 100644
--- a/xen/include/asm-x86/domain.h
+++ b/xen/include/asm-x86/domain.h
@@ -249,6 +249,8 @@ struct pv_domain
 
     /* map_domain_page() mapping cache. */
     struct mapcache_domain mapcache;
+
+    struct cpumasks *masks;
 };
 
 struct monitor_write_data {
