diff --git a/xen/common/sched_credit.c b/xen/common/sched_credit.c
index 1c80483..a38a63d 100644
--- a/xen/common/sched_credit.c
+++ b/xen/common/sched_credit.c
@@ -994,9 +994,6 @@ csched_vcpu_insert(const struct scheduler *ops, struct vcpu *vc)
 
     BUG_ON( is_idle_vcpu(vc) );
 
-    /* This is safe because vc isn't yet being scheduled */
-    vc->processor = csched_cpu_pick(ops, vc);
-
     lock = vcpu_schedule_lock_irq(vc);
 
     if ( !__vcpu_on_runq(svc) && vcpu_runnable(vc) && !vc->is_running )
diff --git a/xen/common/sched_credit2.c b/xen/common/sched_credit2.c
index 037f9f2..1933ff1 100644
--- a/xen/common/sched_credit2.c
+++ b/xen/common/sched_credit2.c
@@ -318,8 +318,6 @@ struct csched2_dom {
     uint16_t nr_vcpus;
 };
 
-static int csched2_cpu_pick(const struct scheduler *ops, struct vcpu *vc);
-
 /*
  * When a hard affinity change occurs, we may not be able to check some
  * (any!) of the other runqueues, when looking for the best new processor
@@ -958,16 +956,9 @@ csched2_vcpu_insert(const struct scheduler *ops, struct vcpu *vc)
 
     BUG_ON(is_idle_vcpu(vc));
 
-    /* csched2_cpu_pick() expects the pcpu lock to be held */
-    lock = vcpu_schedule_lock_irq(vc);
-
-    vc->processor = csched2_cpu_pick(ops, vc);
-
-    spin_unlock_irq(lock);
-
+    /* Add vcpu to runqueue of initial processor */
     lock = vcpu_schedule_lock_irq(vc);
 
-    /* Add vcpu to runqueue of initial processor */
     runq_assign(ops, vc);
 
     vcpu_schedule_unlock_irq(lock, vc);
diff --git a/xen/common/sched_rt.c b/xen/common/sched_rt.c
index 103e8e0..5b077d7 100644
--- a/xen/common/sched_rt.c
+++ b/xen/common/sched_rt.c
@@ -203,8 +203,6 @@ struct rt_dom {
     struct domain *dom;         /* pointer to upper domain */
 };
 
-static int rt_cpu_pick(const struct scheduler *ops, struct vcpu *vc);
-
 /*
  * Useful inline functions
  */
@@ -847,9 +845,6 @@ rt_vcpu_insert(const struct scheduler *ops, struct vcpu *vc)
 
     BUG_ON( is_idle_vcpu(vc) );
 
-    /* This is safe because vc isn't yet being scheduled */
-    vc->processor = rt_cpu_pick(ops, vc);
-
     lock = vcpu_schedule_lock_irq(vc);
 
     now = NOW();
