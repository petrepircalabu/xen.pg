diff --git a/docs/misc/xen-command-line.markdown b/docs/misc/xen-command-line.markdown
index 0042e0f..15f7f87 100644
--- a/docs/misc/xen-command-line.markdown
+++ b/docs/misc/xen-command-line.markdown
@@ -1091,7 +1091,7 @@ The following resources are available:
   * `rmid_max` indicates the max value for rmid.
 
 ### reboot
-> `= t[riple] | k[bd] | a[cpi] | p[ci] | n[o] [, [w]arm | [c]old]`
+> `= t[riple] | k[bd] | a[cpi] | e[fi] | p[ci] | n[o] [, [w]arm | [c]old]`
 
 > Default: `0`
 
@@ -1109,6 +1109,9 @@ Specify the host reboot method.
 
 `acpi` instructs Xen to reboot the host using RESET_REG in the ACPI FADT.
 
+`efi` instructs Xen to reboot the host using the ResetSystem EFI runtime
+service.
+
 `pci` instructs Xen to reboot the host using PCI reset register (port CF9).
 
 ### sched
diff --git a/xen/arch/x86/shutdown.c b/xen/arch/x86/shutdown.c
index 1c8336f..dbb3b79 100644
--- a/xen/arch/x86/shutdown.c
+++ b/xen/arch/x86/shutdown.c
@@ -31,19 +31,22 @@ enum reboot_type {
         BOOT_TRIPLE = 't',
         BOOT_KBD = 'k',
         BOOT_ACPI = 'a',
+        BOOT_EFI = 'e',
         BOOT_CF9 = 'p',
 };
 
 static int reboot_mode;
+static bool_t reboot_default = 1;
 
 /*
- * reboot=t[riple] | k[bd] | a[cpi] | p[ci] | n[o] [, [w]arm | [c]old]
+ * reboot=t[riple] | k[bd] | a[cpi] | e[fi] | p[ci] | n[o] [, [w]arm | [c]old]
  * warm   Don't set the cold reboot flag
  * cold   Set the cold reboot flag
  * no     Suppress automatic reboot after panics or crashes
  * triple Force a triple fault (init)
  * kbd    Use the keyboard controller. cold reset (default)
  * acpi   Use the RESET_REG in the FADT
+ * efi    Use the ResetSystem EFI runtime service
  * pci    Use the so-called "PCI reset register", CF9
  */
 static enum reboot_type reboot_type = BOOT_ACPI;
@@ -51,6 +54,8 @@ static void __init set_reboot_type(char *str)
 {
     for ( ; ; )
     {
+        reboot_default = 0;
+
         switch ( *str )
         {
         case 'n': /* no reboot */
@@ -63,6 +68,7 @@ static void __init set_reboot_type(char *str)
             reboot_mode = 0x0;
             break;
         case 'a':
+        case 'e':
         case 'k':
         case 't':
         case 'p':
@@ -452,7 +458,21 @@ static struct dmi_system_id __initdata reboot_dmi_table[] = {
 
 static int __init reboot_init(void)
 {
-    dmi_check_system(reboot_dmi_table);
+    /*
+     * Only do the DMI check if reboot_type hasn't been overridden
+     * on the command line
+     */
+    if ( !reboot_default )
+        return 0;
+
+    /*
+     * If no quirks apply and the ACPI Hardware Reduced bit is set, prefer EFI
+     * runtime services over ACPI.
+     */
+    if ( !dmi_check_system(reboot_dmi_table) &&
+         (acpi_gbl_FADT.flags & ACPI_FADT_HW_REDUCED) )
+        reboot_type = BOOT_EFI;
+
     return 0;
 }
 __initcall(reboot_init);
@@ -504,9 +524,6 @@ void machine_restart(unsigned int delay_millisecs)
         tboot_shutdown(TB_SHUTDOWN_REBOOT);
     }
 
-    if ( efi_platform )
-        efi_reset_system(reboot_mode != 0);
-
     /* Rebooting needs to touch the page at absolute address 0. */
     *((unsigned short *)__va(0x472)) = reboot_mode;
 
@@ -526,12 +543,12 @@ void machine_restart(unsigned int delay_millisecs)
             /*
              * If this platform supports ACPI reset, we follow a Windows-style
              * reboot attempt sequence:
-             *   ACPI -> KBD -> ACPI -> KBD
+             *   ACPI -> KBD -> ACPI -> KBD -> EFI
              * After this we revert to our usual sequence:
-             *   KBD -> TRIPLE -> KBD -> TRIPLE -> KBD -> ...
+             *   TRIPLE -> KBD -> TRIPLE -> KBD -> ...
              */
             reboot_type = (((attempt == 1) && (orig_reboot_type == BOOT_ACPI))
-                           ? BOOT_ACPI : BOOT_TRIPLE);
+                           ? BOOT_ACPI : BOOT_EFI);
             break;
         case BOOT_TRIPLE:
             asm volatile ("lidt %0; int3" : : "m" (no_idt));
@@ -541,6 +558,11 @@ void machine_restart(unsigned int delay_millisecs)
             acpi_reboot();
             reboot_type = BOOT_KBD;
             break;
+        case BOOT_EFI:
+            if ( efi_platform )
+                efi_reset_system(reboot_mode != 0);
+            reboot_type = BOOT_TRIPLE;
+            break;
         case BOOT_CF9:
             {
                 u8 cf9 = inb(0xcf9) & ~6;
