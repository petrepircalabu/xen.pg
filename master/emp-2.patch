diff --git a/tools/xenguest/control.c b/tools/xenguest/control.c
index a982483..68e96a6 100644
--- a/tools/xenguest/control.c
+++ b/tools/xenguest/control.c
@@ -84,11 +84,26 @@ Example:
 
 
 */
-int sent_event_migrate_completed(struct demu_client cli)
+int send_event_migrate_completed(struct demu_client cli)
 {
    char msg[256];
    INFO("Sending event");
-   sprintf(msg, "{ \"event\" : \"MIGRATION\", \"data\": {\"status\":\"completed\"}}}\n");
+   sprintf(msg, "{ \"event\" : \"MIGRATION\", \"data\": {\"status\":\"completed\"}}\n");
+   return reply(cli, msg);
+}
+
+
+int send_event_migrate_progress(struct demu_client cli, int sent, int remaining, int iter)
+{
+   char msg[256];
+   char iters[60] = "";
+
+   if (iter>=0)
+     sprintf(iters,",\"iteration\": %d", iter);
+
+   sprintf(msg, "{ \"event\" : \"MIGRATION\", \"data\": {"
+             "\"sent\": %d,\"remaining\": %d%s}}\n",sent, remaining, iters);
+
    return reply(cli, msg);
 }
 
@@ -111,26 +126,53 @@ int send_error(struct demu_client cli, char* ret)
 }
 
 
-int run_in_thread(void *(*func) (struct threadargs *), struct threadargs *args)
+void* run_thread(void *vargs) {
+   struct threadargs* args = (struct threadargs*) vargs;
+   args->func(args);
+
+   if (args->is_locked) {
+       args->is_locked = 0;
+       pthread_mutex_unlock(args->lock);
+   }
+
+   free(args);
+   return NULL;
+}
+
+int emp_unlock(struct threadargs *args)
+{
+   if (args->is_locked){
+       args->is_locked = 0;
+       pthread_mutex_unlock(args->lock);
+       return 0;
+   } else {
+       ERR("Error - unlocking unlocked lock");
+       return -1;
+   }
+}
+
+int run_in_thread(void (*func) (struct threadargs *), struct threadargs *args)
 {
    struct threadargs *targs;
    pthread_t thread;
    int rc;
-   void *(*vfunc) (void *);
-   vfunc = (void *(*) (void *)) func;
+//   void *(*vfunc) (void *);
+//   vfunc = (void *(*) (void *)) func;
 
    targs = malloc(sizeof(struct threadargs));
    targs->cli = args->cli;
    targs->fd = args->fd;
    targs->lock = &runstate.lock;
+   targs->func = func;
 
    pthread_mutex_lock(targs->lock);
+   targs->is_locked=1;
 
-   rc = pthread_create(&thread, NULL, vfunc, targs);
+   rc = pthread_create(&thread, NULL, run_thread, targs);
    if (rc == 0)
        pthread_detach(thread);
    else {
-      pthread_mutex_unlock(&runstate.lock);
+      pthread_mutex_unlock(targs->lock);
       if (args->fd != -1)
           close(args->fd);
       send_error(args->cli, "thread fail");
diff --git a/tools/xenguest/control.h b/tools/xenguest/control.h
index 304f4d1..d47a90a 100644
--- a/tools/xenguest/control.h
+++ b/tools/xenguest/control.h
@@ -31,11 +31,13 @@ struct threadargs {
     struct demu_client cli;
     int fd;
     pthread_mutex_t *lock;
+    int is_locked;
+    void (*func)(struct threadargs *);
 };
 
 struct command_actions {
    enum command_num cmd;
-   void* (*func)(struct threadargs *);
+   void (*func)(struct threadargs *);
    int in_thread;
 };
 
@@ -52,6 +54,7 @@ int control_sock_init(char *name, struct control_sock_inf *inf, struct command_a
 int control_fdset(struct control_sock_inf *inf, fd_set *fds);
 int control_fdread(struct control_sock_inf *inf, fd_set *fds, int activity);
 
-int sent_event_migrate_completed(struct demu_client cli);
+int send_event_migrate_completed(struct demu_client cli);
+int send_event_migrate_progress(struct demu_client cli, int sent, int remaining, int iter);
 int send_return(struct demu_client cli, char* ret);
 int send_error(struct demu_client cli, char* ret);
diff --git a/tools/xenguest/emp.h b/tools/xenguest/emp.h
index a7f5630..c0f2b6b 100644
--- a/tools/xenguest/emp.h
+++ b/tools/xenguest/emp.h
@@ -5,6 +5,7 @@ enum command_num {
     cmd_migrate_pause,
     cmd_migrate_paused,
     cmd_migrate_progress,
+    cmd_migrate_nonlive,
     cmd_quit,
     cmd_number
 };
@@ -20,6 +21,7 @@ struct command_names _cmd_name[] = {                \
     {"migrate_abort",0, cmd_migrate_abort},         \
     {"migrate_init",1, cmd_migrate_init},           \
     {"migrate_live",0, cmd_migrate_live},           \
+    {"migrate_nonlive",0, cmd_migrate_nonlive },    \
     {"migrate_pause",0, cmd_migrate_pause},         \
     {"migrate_paused",0, cmd_migrate_paused},       \
     {"migrate_progress",0, cmd_migrate_progress},   \
diff --git a/tools/xenguest/xenguest.c b/tools/xenguest/xenguest.c
index 6abb6a4..9bb4cef 100644
--- a/tools/xenguest/xenguest.c
+++ b/tools/xenguest/xenguest.c
@@ -542,38 +542,36 @@ static void do_test(void)
 }
 
 static sem_t sem_stopped;
+static int live_stop = 0;
 //static sem_t sem_done;
 
 struct demu_client progress_cli;
 
-void* do_cmd_progress(struct threadargs *args)
+void do_cmd_progress(struct threadargs *args)
 {
 /*    report_report = true; */
 //    sem_wait(&sem_done);
     progress_cli = args->cli;
     xg_info("setting progress_cli to %d", progress_cli.num);
     send_return(args->cli, NULL);
-    return NULL;
 }
 
 static int running=1;
 
-void* do_cmd_quit(struct threadargs *args)
+void do_cmd_quit(struct threadargs *args)
 {
    send_return(args->cli, NULL);
    running = 0;
-   return NULL;
 }
 
 
-void* not_supported(struct threadargs *args)  {
+void not_supported(struct threadargs *args)  {
    xg_err("Not supported");
    send_error(args->cli, "Not supported");
-   return NULL;
 }
 
 
-void* do_migrate_init(struct threadargs *args)
+void do_migrate_init(struct threadargs *args)
 {
 
    opt_fd = args->fd;
@@ -581,45 +579,93 @@ void* do_migrate_init(struct threadargs *args)
    sem_init(&sem_stopped,0,0);
 //    sem_init(&sem_done,0,0);
    progress_cli.num = -1;
-   return NULL;
 }
 
 int emu_suspend_callback(void *data)
 {
-  int r;
-  r=sem_wait(&sem_stopped);
-
+   int r;
+   xg_info("waiting for suspend");
+   r=sem_wait(&sem_stopped);
+   xg_info("suspend was recived");
    return 1;
 }
 
-void* do_migrate_live(struct threadargs *args)
+/* Monitor process */
+int xenguest_precopy_policy(
+    struct precopy_stats stats, void *user)
 {
+    int stop = live_stop;
+
+    if (stats.dirty_count >= 0) {
+        struct demu_client *cli = (struct demu_client *)user;
+        xg_info("Checking live policy.  %ld / %d for %d", stats.dirty_count, stats.total_written ,stats.iteration);
+        send_event_migrate_progress(*cli, stats.total_written, stats.dirty_count, stats.iteration);
+    }
+
+    if (stop)
+         xg_info("passing down stop message");
+    else if (stats.dirty_count == 0) {
+         xg_info("No dirty pages, finishing migration");
+         stop = 1;
+    }
+
+   return (stop)?XGS_POLICY_STOP_AND_COPY:XGS_POLICY_CONTINUE_PRECOPY;
+}
+
+
+
+void do_migrate_live(struct threadargs *args)
+{
+   opt_flags |= XCFLAGS_LIVE;
+
    send_return(args->cli, NULL);
 
-   emu_stub_xc_domain_save(opt_fd, 0, 0, opt_flags, true);
-//   sem_post(&sem_done);
-  if (progress_cli.num >= 0)
-       sent_event_migrate_completed(progress_cli);
-  else
-      xg_info("No cli watching");
+   emu_stub_xc_domain_save(opt_fd, (void*) &args->cli, opt_flags, true);
+   xg_info(" Finished, send compleate");
+   if (progress_cli.num >= 0)
+       send_event_migrate_completed(progress_cli);
+   else
+       xg_info("No cli watching");
 
+}
+
+void do_migrate_nonlive(struct threadargs *args)
+{
+   opt_flags &= ~XCFLAGS_LIVE;
+
+   send_return(args->cli, NULL);
+
+   emu_stub_xc_domain_save(opt_fd, (void*) &args->cli, opt_flags, true);
+   xg_info(" Finished, send compleate");
+   if (progress_cli.num >= 0)
+       send_event_migrate_completed(progress_cli);
+   else
+       xg_info("No cli watching");
 
-   return NULL;
 }
 
-void* do_migrate_paused(struct threadargs *args)
+
+
+void do_migrate_paused(struct threadargs *args)
 {
    send_return(args->cli, NULL);
    sem_post(&sem_stopped);
-   return NULL;
 }
+
+void do_migrate_pause(struct threadargs *args)
+{
+   send_return(args->cli, NULL);
+   live_stop=1;
+}
+
 struct command_actions actions[] = {
     {cmd_migrate_abort,    &not_supported, 0 },
     {cmd_migrate_init,     &do_migrate_init, 0 },
     {cmd_migrate_live,     &do_migrate_live, 1 },
-    {cmd_migrate_pause,    &not_supported, 0 },
+    {cmd_migrate_pause,    &do_migrate_pause, 0 },
     {cmd_migrate_paused,   &do_migrate_paused, 0 },
     {cmd_migrate_progress, &do_cmd_progress,  0 },
+    {cmd_migrate_nonlive,  &do_migrate_nonlive, 1},
     {cmd_quit,             &do_cmd_quit,      0 }
 };
 
diff --git a/tools/xenguest/xenguest_stubs.c b/tools/xenguest/xenguest_stubs.c
index bf52a6c..3250b1a 100644
--- a/tools/xenguest/xenguest_stubs.c
+++ b/tools/xenguest/xenguest_stubs.c
@@ -1090,9 +1090,7 @@ void migration_safety_checks(void)
 
 #define GENERATION_ID_ADDRESS "hvmloader/generation-id-address"
 
-
-
-int emu_stub_xc_domain_save(int fd, int max_iters, int max_factors,
+int emu_stub_xc_domain_save(int fd, void* data,
                         int flags, int hvm)
 {
     int r;
@@ -1100,8 +1098,8 @@ int emu_stub_xc_domain_save(int fd, int max_iters, int max_factors,
         {
             .suspend = emu_suspend_callback,
             .switch_qemu_logdirty = switch_qemu_logdirty,
-            .data = NULL,
-            .precopy_policy = NULL,
+            .data = data,
+            .precopy_policy = xenguest_precopy_policy,
         };
 
     migration_safety_checks();
diff --git a/tools/xenguest/xg_internal.h b/tools/xenguest/xg_internal.h
index 0f7e5a5..4dfdab8 100644
--- a/tools/xenguest/xg_internal.h
+++ b/tools/xenguest/xg_internal.h
@@ -46,11 +46,10 @@ int stub_xc_linux_build(int c_mem_max_mib, int mem_start_mib,
 int stub_xc_hvm_build(int mem_max_mib, int mem_start_mib, const char *image_name,
                       int store_evtchn, int store_domid, int console_evtchn,
                       int console_domid, unsigned long *store_mfn, unsigned long *console_mfn);
-int stub_xc_domain_save(int fd, int max_iters, int max_factors,
-                        int flags, int hvm);
 
+int stub_xc_domain_save(int fd, int max_iters, int max_factors, int flags, int hvm);
 
-int emu_stub_xc_domain_save(int fd, int max_iters, int max_factors,
+int emu_stub_xc_domain_save(int fd, void* data,
                         int flags, int hvm);
 
 
@@ -78,6 +77,8 @@ static inline uint64_t tv_delta_us(const struct timeval *new,
             (new->tv_usec - old->tv_usec));
 }
 
+int xenguest_precopy_policy(struct precopy_stats stats, void *user);
+
 #endif
 
 /*
